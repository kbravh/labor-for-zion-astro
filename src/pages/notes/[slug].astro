---
import {readFileSync} from 'fs';
import {
  addLinks,
  getBacklinks,
  getSlugToPathMap,
  getTitleAndSlugMaps,
  type Backlink,
} from '../../utils/mdUtils';
// @ts-ignore - untyped dependency
import matter from 'gray-matter';
import MarkdownIt from 'markdown-it';
import MarkdownItAnchor from 'markdown-it-anchor';
import MarkdownItFootnote from 'markdown-it-footnote';
import EmptyNoteLayout from '../../layouts/EmptyNoteLayout.astro';
import NoteLayout from '../../layouts/NoteLayout.astro';
import {dedupeArray} from '../../utils/array';
import {getHeadings} from '../../utils/htmlUtils';
import {Frontmatter, type Heading} from '../../validation/md';
import {
  isScriptureReference,
  parseScriptureReference,
  processScriptureReference,
  expandScriptureReference,
} from '../../utils/scriptures';

const {slug} = Astro.params;
if (!slug) {
  throw new Error('No slug provided');
}

const md = new MarkdownIt({
  html: true,
  linkify: true,
  typographer: true,
})
  .use(MarkdownItFootnote)
  .use(MarkdownItAnchor);

const slugToPathMap = getSlugToPathMap();
const {titleToSlug, slugToTitle} = await getTitleAndSlugMaps();
const titlesWithBacklinks = await getBacklinks();

const filePath = slugToPathMap[slug];
const title = slugToTitle[slug];

let scripture: string[] = [];
if (isScriptureReference(title)) {
  const reference = parseScriptureReference(title);
  const processed = processScriptureReference(reference);
  if (processed) {
    scripture = expandScriptureReference(processed);
  }
}

let noteData:
  | {
      content: string;
      frontmatter: Frontmatter;
      slug: string;
      headings: Heading[];
      backlinks: Backlink[];
      type: 'note';
    }
  | {title: string; slug: string; backlinks: Backlink[]; type: 'empty'};

// if we have a filepath, this is a real page and we can parse and prepare
if (filePath) {
  const source = readFileSync(filePath, 'utf-8');
  const markdown = matter(source);
  const text = await addLinks(titleToSlug, markdown.content);
  const content = md.render(text);
  const frontmatter = markdown.data;
  const parsedFrontmatter = Frontmatter.parse(frontmatter);
  const headings = getHeadings(content);

  // Fill an array with all backlinks that reference this title or its aliases
  let backlinks = [...(titlesWithBacklinks[parsedFrontmatter.title] ?? [])];
  for (const alias of parsedFrontmatter.aliases ?? []) {
    backlinks = [...backlinks, ...(titlesWithBacklinks[alias] ?? [])];
  }

  noteData = {
    content,
    frontmatter: parsedFrontmatter,
    slug,
    headings,
    backlinks: dedupeArray(backlinks, backlink => backlink.slug),
    type: 'note',
  };
  // otherwise, let's check if it's an empty page referenced in other articles
} else {
  const title = slugToTitle[slug];
  if (!title) {
    // This page doesn't exist as a note.
    return Astro.redirect('/404');
  }
  noteData = {
    slug,
    backlinks: titlesWithBacklinks[title] ?? [],
    type: 'empty',
    title,
  };
}

export async function getStaticPaths() {
  const {slugToTitle} = await getTitleAndSlugMaps();
  const paths = Object.keys(slugToTitle).map(slug => ({
    params: {slug},
  }));
  return paths;
}
---

{
  noteData.type === 'empty' && (
    <EmptyNoteLayout {...noteData}>
      {!!scripture.length &&
        scripture.map(verse => <blockquote>{verse}</blockquote>)}
    </EmptyNoteLayout>
  )
}
{
  noteData.type === 'note' && (
    <NoteLayout {...noteData}>
      {!!scripture.length &&
        scripture.map(verse => <blockquote>{verse}</blockquote>)}
    </NoteLayout>
  )
}
